\section{Design decisions}
The design decisions for this project were not made with considerations towards performance or scalability.  Design decisions were based around ease of implementation and demonstration of compiler concepts.

\section{Execution phases}
The bawk interpreter consists of a bytecode compiler and a bytecode runtime environment.  The two are seamlessly integrated into a single executable program, \texttt{bawk}.  By calling this program with a \texttt{-c} option the results of the bytecode compiler are output, and by calling it with no option (or an explicit \texttt{-e}) the the given program is compiled internally to bytecode and then immediately executed in the bytecode interpreter.

\subsection{Bytecode compiler}
\label{sec:bytecode-compiler}
The bytecode compiler consists of a scanner (generated by OCamllex), a parser (generated by OCamlyacc), and the compiler itself.  The scanner parses a sequence of input characters that form a given bawk language program and returns a list of tokens.  The token types include punctuation that has meaning in the language, the C-style comments (\texttt{/*...*/}), identifiers, keywords, constants, and string literals.  Whitespace is consumed by the scanner, but serves no purpose other than to separate tokens.

There is at least one instance of ambiguity in the scanner.  Identifier names, as defined in \S\ref{sec:identifiers}, consist of a letter or underscore followed by letters, underscores, and/or numerals.  However, constants in pattern expressions, as defined in \S\ref{sec:pattern-constants}, consist of a sequence of hexadecimal digits, possibly including the letters 'a'-'f' in uppercase or lowercase.  This leads to possible confusion in the code chunk listed below.  On line 2 it is not known if \texttt{cafe123} is a variable name or a hexadecimal number.  This ambiguity is actually resolved by the parser, which treats ambiguous constants as constants if they are valid hexadecimal.

\begin{lstlisting}[caption=Possibly ambiguous code]
/cafe123:int1/ {
	/cafe123/ {
		/* do_something */
	}
}
\end{lstlisting}

The parser converts the sequence of tokens into an abstract syntax tree (AST).  The types used in the AST are defined in \texttt{ast\_types.mli}, and rely on the OCaml tagged union types to represent the tree.  The OCamlyacc specification for the parser is defined in the \texttt{parser.mly} file.  The parser definition is fairly straight forward.  There is some conversion done at this stage from strings to integers, but primarily it simply builds the AST using the tagged untion types defined in the \texttt{Ast\_types} module.  The root of the generated AST is a \texttt{statement}, specifically a \texttt{Ast\_types.Block} type, which contains a list of \texttt{statement}s.

The \texttt{bawk} compiler can output the AST in a GraphViz format, which is useful for visualizing and debugging the AST.  The \texttt{-ast} flag to the compiler will output GraphViz code.  This can be turned into a PDF by piping it to GraphViz using the command
\begin{center}\tt
bawk .... | dot -Tpdf -o out-file.pdf\rm.
\end{center}
The logic to generate the GraphViz code is the majority of the \texttt{ast.ml} file.  Other functions in that file serve to provide a few helper functions used when parsing the AST.

\bigskip
In the translation phase of the compiler, most of the heavy lifting is done by translating AST structures into basic blocks.  In addition, the compiler keeps track of a a symbol table in the \texttt{env} type in \texttt{compile.ml}.  The structure forms a linked list, with a new node added each time a new, nested scope, is entered.  Each node has a pointer to the parent scope, and a \texttt{StringMap} from symbols to either (1) the jump address for a subroutine, or (2) the index into globals.  The environment also contains additional information for binding variables, which includes the size of the binding.

\subsection{Bytecode operations}
The compiler takes the AST created by the parser portion and translates it to a custom stack-based bytecode.  The instructions for the bytecode are defined in \texttt{bytecode\_types.mli}.  Most of the instructions are related directly to the stack, but several are designed specifically for the application of this language: reading binary files.

The translation phase from the AST to bytecode is really a two phase translation process.  The first does the basic translation from the AST to basic blocks of bytecode.  In this initial translation the various branch instructions are given a unique value referencing a \texttt{Label} instruction.  The \texttt{Label} instruction is a special pseudo instruction that is removed in the second phase of the translation.  When the \texttt{Label} instructions are removed, their address, or position in the instruction list, is noted.  These addresses then replace the values in all the branch instructions, converting them from the value referencing a label to the address of that label.

All the branch instructions in the bytecode operate on absolute addresses.  There is no relative addressing in the bytecode by design, simply for simplicity.  After the second phase of the translation is complete, the \texttt{Label} instructions removed and branch instructions pointing to addresses, the bytecode is ready for the runtime interpreter.

\subsection{Bytecode runtime}
The runtime interpreter is fairly simple, and defined primarily in \texttt{bytecode.ml}.  The runtime executes the stack-based bytecode in a virtual machine environment.  For simplicity the bytecode instructions composing the program, the execution stack, and global variable values are stored in three different arrays: \texttt{instructions}, \texttt{stack}, and \texttt{globals} respectively.  Execution is performed by the recursive \texttt{exec} function, which takes a frame pointer, a stack pointer, and a program counter.

The program counter is simply an index into the \texttt{instructions} array for the instruction being executed in the current cycle.  When the recursive call to \texttt{exec} is made, to execute the next instruction, the program counter is either incremented by one to run the next sequential instruction, or, in the case of a branch or function return instruction, called with some absolute address from the stack or an instruction argument.  Since all branching is to absolute addresses the bytecode interpreter never computes relative offsets from the current program counter.

The stack grows from an index of zero in the \texttt{stack} array upwards, with items pushed and popped as individual instructions are executed.  The argument to \texttt{exec} is a pointer to where the next value can be pushed on the stack.  The stack only holds integer values, which is the primary motivation for not supporting functions, such as a \texttt{printf}-like function, that take string arguments.

Function arguments are placed on the stack, and the frame pointer references the location of these arguments.  The previous frame pointer is also placed onto the stack and reset when the function returns, allowing recursion with arguments to work properly.

Global variables are stored in the \texttt{globals} array, with each symbol, other than function arguments, assigned an offset into this array.  The name `globals' is a bit of a misnomer, since variables local to blocks or functions are also stored in this same array.  The slots in the \texttt{globals} array are not re-used; they last the entire duration of the program and are statically assigned to symbols by the compiler.

The bytecode interpreter \texttt{stack} is limited to 1024 values, and the \texttt{globals} array is limited to this same size of 1024 values.  These limits are \emph{not} enforced by the compiler, but the bytecode interpreter will crash if they are exceeded.  The length of the \texttt{instructions} array is not explicitly limited.
